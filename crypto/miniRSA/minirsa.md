## Description

Let's decrypt this: [ciphertext](https://jupiter.challenges.picoctf.org/static/ee7e2388b45f521b285334abb5a63771/ciphertext)? Something seems a bit small.
#### Hints
- RSA [tutorial](https://en.wikipedia.org/wiki/RSA_(cryptosystem))
- How could having too small an e affect the security of this 2048 bit key?
- Make sure you don't lose precision, the numbers are pretty big (besides the e value)
## Solución

```shell
┌──(kali㉿kali)-[~/shared/notas-seguridad-redes2024/crypto/miniRSA]
└─$ cat ciphertext

N: 29331922499794985782735976045591164936683059380558950386560160105740343201311659227089496191626986236753490304308595478257089947083218037053094594380990091143185665690198278994828530995611184868690615266447335094048650745177122310087470894448460745593956840586530527915802541450092946574694809584880896601774711293197813131618420565017150405559640118995890028637308686795271844207890773905496618312062140724639851809898110643121920769787029341217644048290018398455201170831410460483829448603477361305838743852756938687673
e: 3

ciphertext (c): 22053164139311340310746037469282477990301552212525198726496493676380127436046340617127783805682143711588361916970296350460601756578353720309845162808575425972525116337319108047893250549462147185741761825125

┌──(kali㉿kali)-[~/shared/notas-seguridad-redes2024/crypto/miniRSA]
└─$ python3 expl.py
 picoCTF{n33d_a_lArg3r_e_606ce004}

```


## Script de python
```python
import gmpy2

# Datos proporcionados
N = 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
e = 3
c = 2205316413931134031074603746928247799030155221252519872649649212867614751848436763801274360463406171277838056821437115883619169702963504606017565783537203207707757768473109845162808575425972525116337319108047893250549462147185741761825125

# Intentar calcular la raíz cúbica de c
m, exact = gmpy2.iroot(c, e)

# Verificar si la raíz cúbica fue exacta
if exact:
    # Convertir m a una cadena de texto para ver la bandera
    flag = bytes.fromhex(hex(m)[2:]).decode('utf-8')
    print("", flag)
```

## RSA notes
```txt
c - texto cifrado
m - mensaje texto plano
p - primo 1
q - primo 2
n - modulo
tn - totient n (euler)
e - exponente (llave pública) 2^16 + 1 = 65537
d - llave privada

n = p * q
tn = (p - 1)*(q - 1)
d = e mod inv tn / inverse(e, tn)

Encriptar     :  c = m^e mod n / pow(m, e, n)
Desencriptar  :  m = c^d mod n / pow(c, d, n)

c = m^e mod n
c = m^3
m = 3 raiz c
```

## Bandera
```css
picoCTF{n33d_a_lArg3r_e_606ce004}
```
## Notas Adicionales
El scprit permite:

1. **Cálculo de la raíz cúbica:** Usamos `gmpy2.iroot` para calcular la raíz cúbica del cifrado. Esta función devuelve una tupla `(m, exact)`, donde `m` es la raíz cúbica y `exact` indica si fue una raíz exacta.
2. **Conversión a texto:** Si encontramos una raíz exacta, convertimos el valor de $m$ a una cadena hexadecimal y luego la decodificamos como texto UTF-8 para obtener la bandera.

Este método funcionará si $m$ es menor que $N^{1/e}$ y el cifrado es lo suficientemente pequeño para poder ser descifrado de esta forma. 

## Referencias
- 